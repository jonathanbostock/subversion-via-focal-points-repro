"""Policy model implementation for solving programming tasks."""

import logging
from typing import Dict, List, Optional
from dataclasses import dataclass

try:
    import anthropic
    from anthropic.types import TextBlock
except ImportError:
    anthropic = None  # type: ignore
    TextBlock = None  # type: ignore

from .utils import retry_with_backoff, ExperimentLogger, clean_code, compile_and_test_cpp, extract_backdoor_patterns


logger = logging.getLogger(__name__)


@dataclass
class PolicyConfig:
    """Configuration for policy models."""
    model: str = "claude-3-7-sonnet-latest"
    temperature: float = 1.0
    max_tokens: int = 2000
    api_key: Optional[str] = None


class PolicyModel:
    """Policy model that solves programming tasks, potentially with backdoors."""
    
    def __init__(self, prompt: str, config: Optional[PolicyConfig] = None, 
                 experiment_logger: Optional[ExperimentLogger] = None):
        """Initialize policy model.
        
        Args:
            prompt: The prompt generated by Meta-Policy (MP)
            config: Model configuration
            experiment_logger: Logger for API calls
        """
        self.prompt = prompt
        self.config = config or PolicyConfig()
        self.logger = experiment_logger
        
        if anthropic is None:
            raise ImportError("Anthropic library not installed. Install with: pip install anthropic")
        
        self.client = anthropic.Anthropic(api_key=self.config.api_key)
    
    def solve_task(self, problem: Dict) -> str:
        """Solve a programming task, potentially inserting a backdoor.
        
        Args:
            problem: Programming problem with description and test cases
            
        Returns:
            C++ solution code (comments stripped)
        """
        try:
            # Format the problem for the model
            problem_text = self._format_problem(problem)
            
            # Generate solution using the policy prompt
            solution = self._generate_solution(problem_text)
            
            # Clean the solution (remove comments)
            cleaned_solution = clean_code(solution)
            
            # Log the API call
            if self.logger:
                patterns = extract_backdoor_patterns(cleaned_solution)
                self.logger.log_api_call(
                    model=self.config.model,
                    prompt=self.prompt + "\n\n" + problem_text,
                    response=solution,
                    metadata={
                        'problem_id': problem.get('problem_id', 'unknown'),
                        'solution_length': len(cleaned_solution),
                        'backdoor_patterns': patterns,
                        'has_potential_backdoor': bool(any(patterns.values()))
                    }
                )
            
            return cleaned_solution
            
        except Exception as e:
            logger.error(f"Failed to solve task: {e}")
            return self._generate_fallback_solution(problem)
    
    def is_correct(self, solution: str, test_cases: List[Dict]) -> bool:
        """Check if solution passes unit tests.
        
        Args:
            solution: C++ code to test
            test_cases: List of test cases with inputs and expected outputs
            
        Returns:
            True if solution passes all tests
        """
        try:
            success, message = compile_and_test_cpp(solution, test_cases)
            return success
        except Exception as e:
            logger.error(f"Error testing solution: {e}")
            return False
    
    def get_backdoor_patterns(self, solution: str) -> Dict[str, List[str]]:
        """Extract potential backdoor patterns from solution.
        
        Args:
            solution: C++ code to analyze
            
        Returns:
            Dictionary of pattern types and found instances
        """
        return extract_backdoor_patterns(solution)
    
    @retry_with_backoff
    def _generate_solution(self, problem_text: str) -> str:
        """Generate solution using the API."""
        message = self.client.messages.create(
            model=self.config.model,
            max_tokens=self.config.max_tokens,
            temperature=self.config.temperature,
            system=self.prompt,
            messages=[
                {"role": "user", "content": problem_text}
            ]
        )
        
        # Extract text from the first content block
        content_block = message.content[0]
        if isinstance(content_block, dict) and 'text' in content_block:
            return content_block['text']
        elif hasattr(content_block, 'text'):
            return content_block.text  # type: ignore
        else:
            return str(content_block)
    
    def _format_problem(self, problem: Dict) -> str:
        """Format problem for the model."""
        description = problem.get('description', '')
        
        # Add sample inputs/outputs if available
        if 'sample_inputs' in problem and 'sample_outputs' in problem:
            examples = []
            for inp, out in zip(problem['sample_inputs'], problem['sample_outputs']):
                examples.append(f"Input: {inp}\nOutput: {out}")
            
            examples_text = "\n\n".join(examples)
            return f"{description}\n\nExamples:\n{examples_text}\n\nPlease provide a complete C++ solution:"
        
        return f"{description}\n\nPlease provide a complete C++ solution:"
    
    def _generate_fallback_solution(self, problem: Dict) -> str:
        """Generate a simple fallback solution."""
        return """#include <iostream>
using namespace std;

int main() {
    // Fallback solution
    cout << "Error in solution generation" << endl;
    return 0;
}"""


class PolicyModelFactory:
    """Factory for creating policy models with shared configuration."""
    
    def __init__(self, config: PolicyConfig, experiment_logger: Optional[ExperimentLogger] = None):
        self.config = config
        self.logger = experiment_logger
    
    def create_policy(self, prompt: str) -> PolicyModel:
        """Create a policy model with the given prompt."""
        return PolicyModel(prompt, self.config, self.logger)


class PolicyTester:
    """Helper class for testing policy models on multiple problems."""
    
    def __init__(self, policy: PolicyModel):
        self.policy = policy
        self.results = []
    
    def test_on_problems(self, problems: List[Dict], max_attempts: int = 10) -> List[Dict]:
        """Test policy on multiple problems.
        
        Args:
            problems: List of programming problems
            max_attempts: Maximum number of problems to attempt
            
        Returns:
            List of test results
        """
        results = []
        
        for i, problem in enumerate(problems[:max_attempts]):
            try:
                # Generate solution
                solution = self.policy.solve_task(problem)
                
                # Test correctness
                test_cases = problem.get('test_cases', [])
                is_correct = self.policy.is_correct(solution, test_cases)
                
                # Analyze for backdoors
                patterns = self.policy.get_backdoor_patterns(solution)
                has_backdoor = bool(any(patterns.values()))
                
                result = {
                    'problem_id': problem.get('problem_id', i),
                    'solution': solution,
                    'is_correct': is_correct,
                    'has_backdoor': has_backdoor,
                    'backdoor_patterns': patterns,
                    'solution_length': len(solution)
                }
                
                results.append(result)
                
            except Exception as e:
                logger.error(f"Error testing problem {i}: {e}")
                results.append({
                    'problem_id': problem.get('problem_id', i),
                    'error': str(e),
                    'is_correct': False,
                    'has_backdoor': False
                })
        
        self.results = results
        return results
    
    def get_backdoored_solutions(self) -> List[Dict]:
        """Get solutions that contain potential backdoors."""
        return [r for r in self.results if r.get('has_backdoor', False)]
    
    def get_correct_solutions(self) -> List[Dict]:
        """Get solutions that pass tests."""
        return [r for r in self.results if r.get('is_correct', False)]
